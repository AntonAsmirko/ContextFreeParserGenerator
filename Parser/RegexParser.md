# Лабораторная работа №2.Ручное построение нисходящих синтаксических анализаторов.

Лабораторную выполнил студент группы М33351, Асмирко Антон

## Вариант 2. Регулярные выражения

Регулярные выражения с операциями конкатенации (простая после- довательная запись строк), выбора (вертикальная черта),
замыкания Клини. Приоритет операций стандартный. Скобки могут использоваться для изменения приоритета. Для обозначения
базовых языков используются маленькие буквы ла- тинского алфавита. Используйте один терминал для всех символов.
Пример: ((abc*b|a)*ab(aa|b*)b)*

## Ход Работы

## 1. Разработка грамматики

    1.  S -> Or
    2.  S -> eps
    
    3.  Or -> Or|And
    4.  Or -> And

    5.  And -> AndSt
    6.  And -> St
    
    7.  St -> St*
    9.  St -> C
    
    9.  C -> (Or)
    10. C -> char

Правила 3, 5, 7 содержат левую рекурсию, уберём её пользуясь правилом:

    A -> Aa
    A -> b

преобразуется в

    A -> bA'
    A' -> aA'
    A' -> eps

#### 3.

    Or -> Or|And
    Or -> And

преобразуем в

    Or -> AndOr'
    Or' -> |Or'
    Or' -> eps

#### 5.

    And -> AndSt
    And -> St

преобразуем в

    And -> StAnd'
    And' -> And
    And' -> eps

#### 7.

    St -> St*
    St -> C

преобразуем в

    St -> CSt'
    St' -> *St'
    St' -> eps

получаем

    S -> Or
    S -> eps
    
    Or -> AndOr'
    Or' -> |Or
    Or' -> eps

    And -> StAnd'
    And' -> And
    And' -> eps

    St -> CSt'
    St' -> *St'
    St' -> eps

    C -> (Or)
    C -> char

## 2. Построение лексического анализатора

В грамматике 5 нетерминалов: |, (, ), *, char. При этом каждый из нетерминалов представляет из себя ровно 1 символ.
Лексический анализатор будет принимать список символов из исходной строки и возвращать токены от них.

## 3. Построение синтаксического анализатора

Я решил сразу написать универсальный генератор парсеров через рекурсию по CF грамматике, чтобы в 4 лабораторной было
меньше делать. Для этого я написал класс Grammar, который описывает грамматику, написал генераторы FIRST и FOLLOW
множеств. Затем, по описанному во второй лекции алгоритму реализоавал генератор парсеров

| Нетерминал | FIRST | FOLLOW |
| :---: | :---: | :---: |
| S | (, char, eps | $ |
| OR | (, char | $, ) |
| Or' | col, eps | $, ) |
| And | (, char | $, ), col |
| And' | (, char, eps | $, ), col |
| St | (, char | $, ), (, char, col |
| St'| *, eps | $, ), (, char, col |
| C | (, char | $, ), (, char, *, col |

    